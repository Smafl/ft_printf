Part 1.
At first I made a state machine for this project. Here we can see the states and tranisitions between them:

https://www.plantuml.com/plantuml/uml/XOz1QyCm38Nl_XNQeNGz67gTOQF_P9X4RGrkcjaAw_xzAkDE9cBknIZlAUzzEcJoYPPBDFU140XlLCUlnSTm39Zgzp7wKns_mqZdEiy9Xv33TNea_Cpui3x5v62mzaDY7Mn4vS71SFO9Nl4su4omsPc_NTuf0AwyUUKK7WTX8ZpTfPTtsAys6XG7uvLMDaExyZRH2YnXffrX07q9gugIt_y0nLHix2Wi4HLHILT88gi6iTgAgdOxv9QzVJDDhgfNPjEaFDMdDfe3jdRRinciQtQOEyHFU7bBvOcgVpZWD2wN-0i0

@startuml
state text
state format
state flag
state width
state precision
state type
state undef_precision

text --> format: %
text --> text: char (except %)

format --> flag: flags
format --> width: integer != 0
format --> undef_precision: dot
format --> type: types
format --> text: char (rest)

flag --> flag: flags
flag --> width: integer != 0
flag --> undef_precision: dot
flag --> type: types
flag --> text: char (rest)

width --> undef_precision: dot
width --> type: types
width --> text: char (rest)
width --> width: 0-9

undef_precision --> type: types
undef_precision --> text: char (rest)
undef_precision --> precision: '-'
undef_precision --> precision: 0-9

precision --> precision: 0-9
precision --> format: %
precision --> type: types
precision --> text: char (rest)

type --> format: %
type --> text: char (rest)
@enduml

Then I made a simple function for parsing a given string and printing it as "state-symbol-state". For exsample:
parse_str("a%10dx");
output would be:
text
a
text
%
format
1
width
0
width
d
type
x
text

Part 2.
I change my function that now it stores all parts in variables and prints in next format:
parse_str("hello world %-022dsmafl");
output would be:
text: "hello world "
format:
	flag: minus, zero
	width: 22
	type: d
text: "smafl"

Part 3.
I modified my function that now it takes all args and printed it in rigth way.
And in this part I divided it for difference files for more comfortable work.

Part 4.
For norminette :(


A 		B 		!A 		A & B 		A | B 		A ^ B
0 		0 		1 		  0 		  0 		  0
0 		1 		1 		  0 		  1 		  1
1 		0 		0 		  0 		  1 		  1
1 		1 		0 		  1 		  1 		  0

^ -- XOR is exlusive OR (if one is true)

Bitwise shifts:
13 is 1101
(13 << 2) is 110100 and it's 52
Shifting to the left by k multiply number to 2 in power k. (x << k) == x * 2 in pow k

13 is 1101
(13 >> 2)  is 0011 and it's 3
Then (x >> k) == x / 2 in pow k

for i in 1..30
	if (x & (1 << i)) != 0
		print(1)
	else
		print(0)

Bitwise NOT operator is ~
~5
0101
1010 it's 10

Unsigned short int is 16 bits or 2 bytes.

(Associativity of operators)
return ((unsigned short) 'X' << 8 | '0');
return ((unsigned short) 'x' << 8 | '0');

			0				X 				x
dec			48				88				120
binary		0011 0000		0101 1000		0111 1000

(Big and little endian byte ordering)
0000 0000 0000 0000
0101 1000 0011 0000
It's 22576 or 0X

0111 1000 0011 0000
It's 30768 or 0x

